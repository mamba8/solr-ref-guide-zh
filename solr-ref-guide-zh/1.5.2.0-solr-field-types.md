# Solr字段类型 #
字段类型定义了Solr怎样解析字段的数据以及怎样处理字段的查询。Solr默认提供了很多字段类型，也可以自定义类型。
本节包含以下内容：

- 字段类型定义及属性
- Solr自带的字段类型
- 货币和汇率类型
- 日期类型
- 枚举类型
- 外部文件
- 字段属性示例

#### 相关话题 ####
- [SchemaXML-DataTypes](http://wiki.apache.org/solr/SchemaXml#Data_Types)
- [FieldType Javadoc](http://lucene.apache.org/solr/4_10_0/solr-core/org/apache/solr/schema/FieldType.html)

### 字段类型定义及属性 ###
字段类型的定义包含以下四点：

- 字段类型的名称（必须有）
- 实现类名（必须有）
- 如果字段类型是TextField，需要包含该字段类型的分词器
- 字段类型属性-取决于实现类，某些属性是你必须的

**Schema.xml中定义字段类型**
字段类型是在schema.xml中的types标签中定义的。每个字段类型定义在fieldType标签中，以下是text_general类型的定义：

	<fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
	  <analyzer type="index">
	    <tokenizer class="solr.StandardTokenizerFactory"/>
	    <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"
	enablePositionIncrements="true" />
	    <!-- in this example, we will only use synonyms at query time
	    <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt"
	ignoreCase="true" expand="false"/>
	    -->
	    <filter class="solr.LowerCaseFilterFactory"/>
	  </analyzer>
	  <analyzer type="query">
	    <tokenizer class="solr.StandardTokenizerFactory"/>
	    <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"
	enablePositionIncrements="true" />
	    <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"
	ignoreCase="true" expand="true"/>
	    <filter class="solr.LowerCaseFilterFactory"/>
	  </analyzer>
	</fieldType>

示例中的第一行包含类型的名称“text_general”和实现类名“solr.TextField”。其他部分是对字段解析的定义，参见[Understanding Analyzers, Tokenizers, and Filters]().

实现类来保证字段会被正确的处理，schema.xml中类名，solr是org.apapche.solr.schema或者org.apache.solr.analysis的缩写。因此，solr.TextField实际是org.apache.solr.schema.TextField类。

**字段类型属性**
实现类定义了该类型的大部分实现行为，另外可以定义可选属性。如以下示例中定义了另外两个属性sortMissingLast和omitNorms：

	<fieldType name="date" class="solr.TrieDateField"
	           sortMissingLast="true" omitNorms="true"/>

字段类型的属性主要包含以下三类：

- 类型实现类的属性
- [General Properties]()Solr每种字段类型都支持的通用属性
- [Field Default Properties]()可以覆盖字段的默认属性

*General Properties*

<table>
<tr>
	<th>Property</th><th>Description</th><th>Values</th>
</tr>
<tr>
	<td>name</td><td>字段类型的名称，建议名称仅包含字母数字和下划线，不以数字开头，虽然目前并没有严格限制</td><td></td>
</tr>
<tr>
	<td>class</td><td>该类型用于存储和索引字段数据的类名，可以使用“solr.”来简写类名，如果使用第三方类则需要写全类名。“solr.TextField”的完整类名是“org.apache.solr.schema.TextField”.</td><td></td>
</tr>
<tr>
	<td>positionIncrementGap</td><td>用于多值类型的字段，指定各值之间的距离，防止出现假词组匹配出现</td><td>integer</td>
</tr>
<tr>
	<td>autoGeneratePhraseQueries</td><td>用于文本类型字段，如果为true，Solr自动将临近的词作为词组查询，如果为false，则词组必须用双引号引起来才被认为是词组</td><td>true/false</td>
</tr>
<tr>
	<td>docValuesFormat</td><td>自定义DocValuesFormat，需要在solrconfig.xml中定义SchemaCodecFactory</td><td></td>
</tr>
<tr>
	<td>postingsFormat</td><td>自定义PostingFormat，需要在solrconfig.xml中定义SchemaCodecFactory</td><td></td>
</tr>
</table>

<table>
<tr><td>
<img src="images/icon-hint.png" /> Lucene索引向后兼容只支持默认的codec。如果你使用schema.xml中自定义的postingFormat和docValuesFormat，当升级Solr版本时，你需要在升级前改为使用默认的codec并且optimize索引文件来使之生效，或者在升级后完全重建索引。
</td></tr>
</table>

*Field Default Properties*
<table>
<tr>
	<th>Property</th><th>Description</th><th>Values</th>
</tr>
<tr>
	<td>indexed</td><td>如果为true，字段的值可以用于查询</td><td>true/false</td>
</tr>
<tr>
	<td>stored</td><td>如果为true，字段的值可以在查询结果中返回</td><td>true/false</td>
</tr>
<tr>
	<td>docValues</td><td>如果为true，字段的值会被放到一个基于列的[DocValues]()结构中</td><td>true/false</td>
</tr>
<tr>
	<td>sortMissingFirst<br/>sortMissingLast</td><td>当没有指定排序字段时，文档的排序方式。在Solr3.5以后，只对数值类型、Trie和日期类型有效</td><td>true/false</td>
</tr>
<tr>
	<td>multiValued</td><td>如果为true，表示该类型的字段在一个文档中可以包含多个值</td><td>true/false</td>
</tr>
<tr>
	<td>omitNorms</td><td>如果为true，会忽略该字段的norm计算（禁用基于文档长度的计算和该字段索引时的评分计算，节省内存）。默认对所有原始类型（非分词的字段类型）为true，如int, float, data, bool, string.只有全文本字段或者需要在建索引时计算评分时才需要norms</td><td>true/false</td>
</tr>
<tr>
	<td>omitTermFreqAndPositions</td><td>如果为true，忽略词频、位置信息，禁用会对性能有一定提升，而且会减少索引的存储空间。当基于位置的查询应用到该属性为true的字段时会查不到文档。该属性对非文本类型字段默认为true。</td><td>true/false</td>
</tr>
<tr>
	<td>omitPositions</td><td>和omitTermFreqAndPositions类似，但保留了词频信息</td><td>true/false</td>
</tr>
<tr>
	<td></td><td></td><td></td>
</tr>
</table>